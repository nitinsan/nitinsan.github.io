	<!DOCTYPE html>
	<html lang="zxx" class="no-js">
	<head>
		<!-- Mobile Specific Meta -->
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
		<!-- Favicon-->
		<link rel="shortcut icon" href="img/fav.png">
		<!-- Author Meta -->
		<meta name="author" content="colorlib">
		<!-- Meta Description -->
		<meta name="description" content="">
		<!-- Meta Keyword -->
		<meta name="keywords" content="">
		<!-- meta character set -->
		<meta charset="UTF-8">
		<!-- Site Title -->
		<title>Personal</title>

		<link href="https://fonts.googleapis.com/css?family=Poppins:100,200,400,300,500,600,700" rel="stylesheet"> 
			<!--
			CSS
			============================================= -->
			<link rel="stylesheet" href="../../css/linearicons.css">
			<link rel="stylesheet" href="../../css/font-awesome.min.css">
			<link rel="stylesheet" href="../../css/bootstrap.css">
			<link rel="stylesheet" href="../../css/magnific-popup.css">			
			<link rel="stylesheet" href="../../css/nice-select.css">							
			<link rel="stylesheet" href="../../css/animate.min.css">
			<link rel="stylesheet" href="../../css/owl.carousel.css">			
			<link rel="stylesheet" href="../../css/jquery-ui.css">			
			<link rel="stylesheet" href="../../css/main.css">
			<link href="../../css/icofont/icofont.min.css" rel="stylesheet">
		    <link href="../../css/remixicon/remixicon.css" rel="stylesheet">
		    <link href="../../css/owl.carousel/assets/owl.carousel.min.css" rel="stylesheet">
		    <link href="../../css/boxicons/css/boxicons.min.css" rel="stylesheet">
		    <link rel="stylesheet" href="https://cdn.rawgit.com/jpswalsh/academicons/master/css/academicons.min.css">
		    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script type="text/javascript" id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
        </script>
		</head>
		<body>	
		<!-- EDIT ME -->
		  <header id="header">
		    <div class="container main-menu">
		    	<div class="row align-items-center justify-content-between d-flex">
			      <div id="logo">
			        <a href="index.html"><img src="../../img/logo.png" alt="" title="" /></a>
			      </div>
			      <nav id="nav-menu-container">
			        <ul class="nav-menu">
			          <li><a href="../../index.html">Home</a></li>
			          <li><a href="../../about.html">About</a></li>
			          <li><a href="../../services.html">Services</a></li>
			          <li><a href="../../portfolio.html">Portfolio</a></li>
			          <li><a href="../../price.html">Pricing</a></li>
			          <li class="menu-has-children"><a href="">Blog</a>
			            <ul>
			              <li><a href="blog-home.html">Blog Home</a></li>
			              <li><a href="blog-single.html">Blog Single</a></li>
			            </ul>
			          </li>	
			          <li class="menu-has-children"><a href="">Pages</a>
			            <ul>
		            	  <li><a href="elements.html">Elements</a></li>
				          <li class="menu-has-children"><a href="">Level 2 </a>
				            <ul>
				              <li><a href="#">Item One</a></li>
				              <li><a href="#">Item Two</a></li>
				            </ul>
				          </li>					                		
			            </ul>
			          </li>					          					          		          
			          <li><a href="../../contact.html">Contact</a></li>
			        </ul>
			      </nav><!-- #nav-menu-container -->		    		
		    	</div>
		    </div>
		  </header><!-- #header -->
		  <!-- EDIT ME -->
		  

			<!-- Start Sample Area -->
<!-- 			<section class="sample-text-area">
				<div class="container">
					<h3 class="text-heading">I love to spread knowledge through my tutorials.</h3>
				</div>
			</section> -->
			<!-- End Sample Area -->
			<!-- Start Align Area -->
			<div class="whole-wrap">
				<div class="container">
					<div class="section-top-border">
						<div class="row">
							<div class="col-md-6 mt-sm-20 left-align-p">
								<div class="">
									<ul class="unordered-list">
                                    <h3> Table of Contents: </h3><br>
                                    <li> <a href="#mathimu"> Mathematical Model of an IMU</a> </li>
                                    <li> <a href="#kf"> Kalman Filter</a> </li>
                                    <ul class="unordered-list">
                                        <li> <a href="#assumptions"> Assumptions</a> </li>
                                        <li> <a href="#mathformulation"> Mathematical Formulation</a> </li>
                                    </ul>
                                    <li> <a href="#ref"> References</a> </li>
									</ul>
							</div>
							</div>
							<!-- <div class="col-md-6 mt-sm-20 right-align-p">
								<img src="img/research/PRGFlow.png" alt="" class="img-fluid">
							</div> -->
						</div>
						<hr>



            <a name='mathimu'></a>

            ## Mathematical Model of an IMU

            <br>
            If you don't know what an IMU is, I would recommend going through my [What is an IMU? tutorial](tutorials/attitudeest/imu).

            Let us assume that our IMU is a 6-DoF one, i.e., it has a 3 axis gyro and a 3 axis acc. A 9-DoF IMU is commonly called MARG (Magnetic, Angular Rate and Gravity) sensor. A simple mathematical model of the gyro and acc is given below.

            Gyroscope Model:<br>

            $$ \omega = \hat{\omega} + \mathbf{b}_g + \mathbf{n}_g $$

            Here, $$\omega$$ is the measured angular velocity from the gyro, $$\hat{\omega}$$ is the latent ideal angular velocity we wish to recover, $$\mathbf{b}_g$$ is the gyro bias which changes with time and other factors like temparature, $$\mathbf{n}_g$$ is the white gaussian gyro noise.

            The gyro bias is modelled as $$ \mathbf{\dot{b}}_g = \mathbf{b}_{bg}(t) \sim \mathcal{N}(0, Q_g) $$ where $$ Q_g$$ is the covariance matrix which models gyro noise. 


            Accelerometer Model:<br>

            $$ \mathbf{a} = R^T(\mathbf{\hat{a}} - \mathbf{g}) + \mathbf{b}_a + \mathbf{n}_a $$

            Here, $$\mathbf{a}$$ is the measured acceleration from the acc, $$\mathbf{\hat{a}}$$ is the latent ideal acceleration we wish to recover, $$R$$ is the orientation of the sensor in the world frame, $$\mathbf{g}$$ is the acceleration due to gravity in the world frame, $$\mathbf{b}_a$$ is the acc bias which changes with time and other factors like temparature, $$\mathbf{n}_a$$ is the the white gaussian acc noise.

            The acc bias is modelled as $$ \mathbf{\dot{b}}_a = \mathbf{b}_{ba}(t) \sim \mathcal{N}(0, Q_a) $$ where $$ Q_a$$ is the covariance matrix which models acc noise. 

            Here the orientation of the sensor is either known from external sources such as a motion capture system or a camera or estimated by sensor fusion. 

            <a name='kf'></a>

            ## Kalman Filter

            <br>
            Before we start talking about the Kalman Filter (KF) formulation, let us formally define coordinate axes we will use. Let the letters $$I, W, B$$ denote inertial, world and body frames respectively. Generally $$B$$ and $$I$$ are the same but they don't have to be. A pre-subscript denotes the source coordinate frame and a pre-superscript denotes the destination coordinate frame. For eg., $${}^{B}_{A}X$$ transforms $$X$$ from coordinate frame $$A$$ to $$B$$. If only a pre-superscript is present, it means that the quantity was measured and is represented in the same coordinate frame represented by the pre-superscript.

            The desired output is to estimate the attitude/angle/orientation of the IMU sensor in the world frame, i.e., estimating $$[\phi, \theta, \psi]^T$$ which is commonly called **Roll, Pitch** and **Yaw** respectively. These are commonly interchanged with **Euler Angles**. However they **ARE NOT THE SAME**. Euler Angles can vary in convention and is generally chosen from 12 unique combinations. For our discussion we'll use Z-Y-X Euler Angles which we'll also refer to as Roll, Pitch and Yaw for X, Y and Z axes respectively. For a detailed explanation [refer to this awesome explanation by Peter Corke](https://petercorke.com/wordpress/roll-pitch-yaw-angles).

            In any of the filters we looked at before there was a tradeoff parameter which determined when the filter should trust which sensor more (gyro or acc). However, these parameters didn't have much physical significance and is hard to tune. Also, it seems that changing these parameters at every time instant would yield the best result. A **Kalman Filter** (KF) does this in a theoretically optimal fashion. <br> 

            A KF formulates this problem (state estimation or attitude estimation in our case) as minimizing a quadratic cost function with respect to the latent correct space and the estimated space. This cost function includes the sensor noise (how much should you trust each sensor) as well as the underlying dynamics of the system (is the IMU placed on a car/quadrotor/hand-held). What if you don't really know where the sensor is going to be used? The answer is simple - you craft a generic enough system dynamics model which would work "well" in most scenarios. <br>

            The aim of a KF is to estimate a **state** (a vector of time varying quantities) given the data from one or more sensors and the knowledge of a process model/system dynamics ("how" the system is moving). The magic of a Kalman filter is that it dynamically weights the estimates from both the process model and sensor measurements. Note that the state could have variables not of all which can be measured like the bias of a gyroscope in our case. This can still be used in the process update. Such a state when not all the variables are not obeserved are called **Augmented State**. <br>

            A KF operates in two steps, i.e., **process update** and **measurement update**. In the process update, the filter uses measurements from a sensor and underlying system dynamics to predict the future state. This is the best you can do withou a measurement update and the estimated state would drift over time. This drift is directly proportional to the amount of error in the process model (how accurately does your process model resemble the real world?). <br>

            In the measurement update, the filter uses measurements from another sensor (hopefully complementary in error to that used in process model) to correct for errors in predicted state. However, none of the sensors used are perfect, how do you trust one more than the other? Simple, you only model the noise charactersistics of each sensor, i.e., the designer's opinion of accuracy of these sensors. You can obtain this from the manufacturer's datasheet or by experimentally obtaining these values. <br>

            Now, let's look at the assumptions a Linear Kalman Filter or Kalman filter formulation makes to obtain the mathematical model.

            <a name='assumptions'></a>

            ### Assumptions
            - All the noise in the system (process noise and measurement noise) is additive white Gaussian noise
            - The prior state is modelled by a Gaussian distribution
            - Both the process and measurement model is linear
            - Markov Property: The future state of the system is conditionally independent of the past states given the current state

            <a name='mathformulation'></a>

            ### Mathematical Formulation

            <br>
            Now let's look at the mathematical formulation of a Kalman Filter. 

            The filter starts by taking as input the current state to predict the future state. Now, you might be wondering what a state is? As discussed before, a state in a Kalman filter is a vector which you would like to estimate. In our case, we would like to estimate the attitude of the IMU. Along with estimating the attitude we would also like to estimate the bias of the gyro so that we could get more accurate estimation. Let us denote our state at time $$t$$ by $$\mathbf{x}_t$$ and is given by <br>

            <center>
            $$
            \mathbf{x}_t = \begin{bmatrix}
            \phi_t \\ 
            \theta_t \\ 
            \psi_t \\
            \mathbf{b}_{g,t}
            \end{bmatrix}
            $$
            </center>
            Here, $$\mathbf{b}_{g,t} \in \mathbb{R}^{3 \times 1} $$ denotes the gyro bias in 3D. 

            Following are the steps for attitude estimation using a Kalman filter.

            - **Step 1: Obtain sensor measurements**<br> Obtain gyro and acc measurements from the sensor. Let $${}^I\omega_t$$ and $${}^I\mathbf{a}_t$$ denote the gyro and acc measurements respectively.


            - **Step 2: Process Update using Gyro Measurements (Prediction)**<br> Compute the predicted next state using the system dynamics. Note that in a KF each state is characterized by its mean and co-variance matrix.<br>
            <center> $$ 
            \hat{\mu_{t+1}} = \mathbf{A}_{t+1}\hat{\mu_{t}} + \mathbf{B}_{t+1}\mathbf{u}_{t+1}$$ <br>
            $$
            \hat{\Sigma_{t+1}} = \mathbf{A}_{t+1}\hat{\Sigma_{t}}\mathbf{A}_{t+1}^T + \mathbf{Q}_{t+1}$$
             <br></center>

            Here, $$ \mu_t$$, $$\Sigma_t$$ denote the mean and co-variance of the state at time $$t$$ and $$\hat{\mu_{t+1}}, \hat{\Sigma_{t+1}}$$ denotes the estimated mean and co-variance of the state at time $$t+1$$. $$\mathbf{Q}_{t+1}$$ denotes the noise matrix modelling how noisy the system dynamics model is. Here, $$\mathbf{A}_{t+1}$$ denotes the **process/dynamics/system model** which mathematically models how the state changes from $$t$$ to $$t+1$$ and is given below. <br>

            <center>
            $$
            \mathbf{A}_{t+1} = \begin{bmatrix}
            1 & 0 & 0 & -\Delta t & 0 & 0\\
            0 & 1 & 0 & 0 & -\Delta t & 0\\
            0 & 0 & 1 & 0 & 0 & -\Delta t\\
            0 & 0 & 0 & 1 & 0 & 0\\
            0 & 0 & 0 & 0 & 1 & 0\\
            0 & 0 & 0 & 0 & 0 & 1\\
            \end{bmatrix}
            $$ <br>
            </center>

            Here, \\(\Delta t\\) is the time elapsed between two samples at \\(t\\) and \\(t+1\\). If no correction is given this prediction would drift due to error in process model. The process model in our case models a constant attitude within the small time instant but the bias integrates over this small time $$\Delta t$$. Also, $$\mathbf{u}_{t+1}$$ represents the input/process vector (in our case this is the vector of euler angle velocities of the IMU in world frame) and is given by <br> 

            <center>
            $$
            \mathbf{u}_{t+1} = \begin{bmatrix}
            \dot{\phi}\\
            \dot{\theta}\\
            \dot{\psi}\\
            \end{bmatrix}
            $$<br>
            $$
            \begin{bmatrix}
            \dot{\phi}\\
            \dot{\theta}\\
            \dot{\psi}\\
            \end{bmatrix} = \mathbf{R}^{-1} {}^I\omega_t  
            $$ <br>
            $$
            \mathbf{R} = \begin{bmatrix}
            \cos \theta & 0 & -\cos \phi \sin \theta \\
            0 & 1 & \sin \phi \\
            \sin \theta & 0 & \cos \phi \cos \theta
            \end{bmatrix}
            $$
            <br>
            </center>

            $$\mathbf{B}_{t+1}$$ denotes the mapping of the input vector to the state vector and is given by <br>

            <center>
            $$
            \mathbf{B}_{t+1} = \begin{bmatrix}
            \Delta t & 0 & 0\\
            0 & \Delta t & 0\\
            0 & 0 & \Delta t\\
            0 & 0 & 0\\
            0 & 0 & 0\\
            0 & 0 & 0\\
            \end{bmatrix}
            $$<br>
            </center>

            Here, the bias is assumed to be not dependent on the attitude which might not be true in real life.<br>

            - **Step 3: Measurement Update using Acc Measurements (Fusion or Correction)** <br> 
            In this step, compute the attitude using acc measurements and use it to obtain the corrected state, i.e., state which is a combination of both the process and measurement steps. This step entails the sensor fusion. <br>

            <center>
            $$
            \mathbf{K}_{t+1} = \hat{\Sigma_{t+1}}\mathbf{C}^T \left( \mathbf{C} \hat{\Sigma_{t+1}} \mathbf{C}^T + \mathbf{R} \right)^{-1}
            $$<br>
            $$
            \mu_{t+1} = \hat{\mu_{t+1}} + \mathbf{K}_{t+1} \left( \mathbf{z}_{t+1} - \mathbf{C} \hat{\mu_{t+1}}\right)
            $$<br>
            $$
            \Sigma_{t+1} = \hat{\Sigma_{t+1}} - \mathbf{K}_{t+1}\mathbf{C}\hat{\Sigma_{t+1}}
            $$<br>
            </center>

            Here, $$\mathbf{z}_{t+1}$$ denotes the observable state by the sensor (this could be a subset of the full state as in our case). The acc is used to obtain the angles as follows <br>

            <center>
            $$
            \phi = \tan^{-1}\left( \frac{a_y}{\sqrt{a_x^2 + a_z^2}} \right)
            $$ <br>
            $$
            \theta = \tan^{-1}\left( \frac{a_x}{\sqrt{a_y^2 + a_z^2}} \right)
            $$ <br>
            <br>
            </center>

            Here, $$\mathbf{C}$$ denotes the mapping from observed state to full state and is given by <br>

            <center>
            $$
            \mathbf{C} = \begin{bmatrix}
            1 & 0 & 0 & 0 & 0 & 0\\
            0 & 1 & 0 & 0 & 0 & 0\\
            0 & 0 & 0 & 0 & 0 & 0\\
            0 & 0 & 0 & 0 & 0 & 0\\
            0 & 0 & 0 & 0 & 0 & 0\\
            0 & 0 & 0 & 0 & 0 & 0\\
            \end{bmatrix}
            $$ <br>
            </center>

            Note that, in our case we don't use the value of $$\psi$$ from the acc readings as it is generally inaccurate. In a real robotic system, the value of $$\psi$$ is obtained from a camera or a compass. The rows of all zeros in $$\mathbf{C}$$ indicate unobservable values in the state vector $$\mathbf{x}$$. 

            **Repeat steps 1 and 2 for every time instant and step 3 whenever a measurement update from acc is available.** The measurement update is generally run about a factor of magnitude slower than the process update for keeping computation complexity low. <br>


            <a name='ref'></a>

            ## References

            - [IMU Attitude Estimation](http://philsal.co.uk/projects/imu-attitude-estimation)
            - [MEAM620 Kalman Filter Notes](https://alliance.seas.upenn.edu/~meam620/wiki/index.php?n=Main.Schedule2015?action=download&upname=2015_kalmanFilter.pdf)
            - Nitin J. Sanket. [Orientation Tracking based Panorama Stiching using Unscented Kalman Filter.](https://github.com/NitinJSanket/ESE650Project2/blob/master/Report/ESE650Project2.pdf)
            - [Does anyone have a 6-DOF IMU Kalman Filter?](https://www.researchgate.net/post/Does_anyone_have_a_6-DOF_IMU_Kalman_Filter)


            <a name='mathimu'></a>

            <h3> Mathematical Model of an IMU </h3><br><br>

            If you don't know what an IMU is, I would recommend going through my <a href="tutorials/attitudeest/imu"> What is an IMU? tutorial </a>.<br><br>

            Let us assume that our IMU is a 6-DoF one, i.e., it has a 3 axis gyro and a 3 axis acc. A 9-DoF IMU is commonly called MARG (Magnetic, Angular Rate and Gravity) sensor. A simple mathematical model of the gyro and acc is given below.<br><br>

            <h5> Gyroscope Model:</h5><br>

            $$ \omega = \hat{\omega} + \mathbf{b}_g + \mathbf{n}_g $$

            Here, \(\omega\) is the measured angular velocity from the gyro, \(\hat{\omega}\) is the latent ideal angular velocity we wish to recover, \(\mathbf{b}_g\) is the gyro bias which changes with time and other factors like temparature, \(\mathbf{n}_g\) is the white gaussian gyro noise.<br><br>


            The gyro bias is modelled as \(\mathbf{\dot{b}}_g = \mathbf{b}_{bg}(t) \sim \mathcal{N}(0, Q_g)\) where \(Q_g\) is the covariance matrix which models gyro noise. <br><br>



            <h5>Accelerometer Model:</h5><br><br>

            $$ \mathbf{a} = R^T(\mathbf{\hat{a}} - \mathbf{g}) + \mathbf{b}_a + \mathbf{n}_a $$

            Here, \(\mathbf{a}\) is the measured acceleration from the acc, \(\mathbf{\hat{a}}\) is the latent ideal acceleration we wish to recover, \(R\) is the orientation of the sensor in the world frame, \(\mathbf{g}\) is the acceleration due to gravity in the world frame, \(\mathbf{b}_a\) is the acc bias which changes with time and other factors like temparature, \(\mathbf{n}_a\) is the the white gaussian acc noise.<br><br>


            The acc bias is modelled as \(\mathbf{\dot{b}}_a = \mathbf{b}_{ba}(t) \sim \mathcal{N}(0, Q_a)\) where \(Q_a\) is the covariance matrix which models acc noise. <br><br>


            Here the orientation of the sensor is either known from external sources such as a motion capture system or a camera or estimated by sensor fusion. <br><br>

            <hr>

            <a name='madgwickfilt'></a>

            <h3>Madgwick Filter</h3><br><br>

            Before we start talking about the madgwick filter formulation, let us formally define coordinate axes we will use. Let the letters \(I, W, B\) denote inertial, world and body frames respectively. Generally \(B\) and \(I\) are the same but they don't have to be. A pre-subscript denotes the source coordinate frame and a pre-superscript denotes the destination coordinate frame. For eg., \({}^{B}_{A}X\) transforms \(X\) from coordinate frame \(A\) to \(B\). If only a pre-superscript is present, it means that the quantity was measured and is represented in the same coordinate frame represented by the pre-superscript.<br><br>

            
             The desired output is to estimate the attitude/angle/orientation of the IMU sensor in the world frame, i.e., estimating \({}^{W}_{I}\mathbf{q}\). We use \(\mathbf{q}\) to denote the orientation represented in the form of a <b>Quaternion</b>. If you don't know much about quaternions, I would highly recommend to read <a href="https://en.wikipedia.org/wiki/Quaternion">this Wikipedia article</a> on quaternions.  <br><br>

            The Mahony filter is a glorified [Complementary Filter](tutorials/attitudeest/imu) with significant improvements to accuracy without significant markup in computation time. Even today, it remains to be one of the most popular filters used in racing quadrotors where time is money. <br><br>


            The Madgwick filter formulates the attitude estimation problem in quaternion space. The general idea of the Madgwick filter is to estimate \({}^{I}_{W}\mathbf{q}_{t+1}\) by fusing/combining attitude estimates by integrating gyro measurements \({}^{I}_{W}\mathbf{q}_{\omega}\) and direction obtained by the accelerometer measurements. In essence, the gyro estimates of attitude are used as accurate depictions in a small amount of time and faster movements and the acc estimates of attitude are used as accurate directions to compensate for long term gyro drift by integration. <br><br>

            As in <a href="tutorials/attitudeest/imu"> Complementary Filter </a>, the attitude is estimated from the gyro by numerical integration. The attitude estimation from the acc is done by using a gradient descent algorithm to solve the following minimzation problem. <br><br>

            $$
             \min_{ {}^{I}_{W}\mathbf{\hat{q}} \in \mathbb{R}^{4 \times 1} } f\left({}^{I}_{W}\mathbf{\hat{q}}, {}^{W}\mathbf{\hat{g}}, {}^{I}\mathbf{\hat{a}} \right)  
            $$

            $$
            f\left({}^{I}_{W}\mathbf{\hat{q}}, {}^{W}\mathbf{\hat{g}}, {}^{I}\mathbf{\hat{a}}  \right)  = {}^{I}_{W}\mathbf{\hat{q^*}} \otimes {}^{W}\mathbf{\hat{g}} \otimes {}^{I}_{W}\mathbf{\hat{q}} - {}^{I}\mathbf{\hat{a}}
            $$<br><br>

            Here, \(\mathbf{q}^*\) denotes the conjugate of \(\mathbf{q}\) and \(\otimes\) indicates quaternion multiplication. \({}^{W}\mathbf{\hat{g}}\) denotes the normalized gravity vector and is given by \({}^{W}\mathbf{\hat{g}} = \begin{bmatrix} 0 & 0 & 0 & 1\end{bmatrix}^T\) and \({}^{I}\mathbf{\hat{a}}\) denotes the normalized acc measurements. From now on \(\mathbf{\hat{x}}\) denotes normalized version of \(\mathbf{x}\). <br><br>

            Following are the steps for attitude estimation using a Madgwick filter (Refer to Fig. 1 shown below for an overview of the algorithm).<br><br>

            <div class="col-md-6 mt-sm-20" > <!-- style="display: flex; text-align: center; justify-content: center;" -->
                 <img src="../../img/tutorials/MadgwickFilterOverview.png" alt="" class="img-fluid" >
                 <div class="figcaption">
                Fig 1: Overview of Madgwick Filter.<br><br>
              </div>
            </div>

            <ul class="unordered-list">
            <li> <h5>Step 1: Obtain sensor measurements</h5><br> Obtain gyro and acc measurements from the sensor. Let \({}^I\omega_t\) and \({}^I\mathbf{a}_t\) denote the gyro and acc measurements respectively. Also, \({}^I\mathbf{\hat{a}}_t\) denotes the normalized acc measurements.</li> <br><br>

            <li> <h5>Step 2 (a): Orientation increment from Acc</h5><br> Compute orientation increment from acc measurements (gradient step). <br><br>

            \( \nabla f\left( {}^{I}_{W}\mathbf{\hat{q}}_{est, t}, {}^{W}\mathbf{\hat{g}}, {}^{I}\mathbf{\hat{a}}_{t+1} \right) =  J^T\left( {}^{I}_{W}\mathbf{\hat{q}}_{est, t}, {}^{W}\mathbf{\hat{g}} \right) f\left( {}^{I}_{W}\mathbf{\hat{q}}_{est, t}, {}^{W}\mathbf{\hat{g}}, {}^{I}\mathbf{\hat{a}}_{t+1} \right) \) <br><br>

            \( f\left( {}^{I}_{W}\mathbf{\hat{q}}_{est, t}, {}^{W}\mathbf{\hat{g}}, {}^{I}\mathbf{\hat{a}}_{t+1} \right) = \begin{bmatrix}  
            2\left( q_2q_4 - q_1q_3\right) - a_x\\
            2\left( q_1q_2 + q_3q_4\right) - a_y\\
            2\left( \frac{1}{2} - q_2^2 - q_3^2\right) - a_z\\
            \end{bmatrix} \) <br><br>

            \( J\left( {}^{I}_{W}\mathbf{\hat{q}}_{est, t}, {}^{W}\mathbf{\hat{g}} \right) = \begin{bmatrix}  
            -2q_3 & 2q_4 & -2q_1 & 2q_2 \\
            2q_2 & 2q_1 & 2q_4 & 2q_3 \\
            0 & -4q_2 & -4q_3 & 0\\
            \end{bmatrix} \) <br><br>


            Update Term (Attitude component from acc measurements) is given by <br><br>

            \(
            {}^{I}_{W}\mathbf{q}_{\nabla, t+1} = - \beta\frac{\nabla f\left( {}^{I}_{W}\mathbf{\hat{q}}_{est, t}, {}^{W}\mathbf{\hat{g}}, {}^{I}\mathbf{\hat{a}}_{t+1} \right)}{\vert \vert  f\left( {}^{I}_{W}\mathbf{\hat{q}}_{est, t}, {}^{W}\mathbf{\hat{g}}, {}^{I}\mathbf{\hat{a}}_{t+1} \right) \vert \vert} 
            \)<br><br>

            Look at green parts in Fig. 1.<br><br></li>

            <li><h5>Step 2 (b): Orientation increment from Gyro</h5><br> Compute orientation increment from gyro measurements (numerical integration).<br>

             \(
            {}^{I}_{W}\mathbf{\dot{q}}_{\omega,t+1} = \frac{1}{2} {}^{I}_{W}\mathbf{\hat{q}}_{est,t}\otimes \begin{bmatrix} 0, {}^{I}\omega_{t+1} \end{bmatrix}^T\) <br><br>
           

            Look at blue parts in Fig. 1.<br><br></li>


            <li><h5>Step 3: Fuse Measurements</h5><br> Fuse the measurments from both the acc and gyro to obtain the estimated attitude \( {}^{I}_{W}\mathbf{\hat{q}}_{est, t+1}\). <br><br>
        
            \(
            {}^{I}_{W}\mathbf{\dot{q}}_{est, t+1} = {}^{I}_{W}\mathbf{\dot{q}}_{\omega, t+1} + {}^{I}_{W}\mathbf{q}_{\nabla, t+1} 
            \) <br><br>

            \( {}^{I}_{W}\mathbf{q}_{est, t+1} = {}^{I}_{W}\mathbf{\hat{q}}_{est, t} + {}^{I}_{W}\mathbf{\dot{q}}_{est, t+1} \Delta t 
            \) <br><br>

            Here, \(\Delta t\) is the time elapsed between two samples at \(t\) and \(t+1\). Look at red parts in Fig. 1.<br><br></li>

            <li><h5>Repeat steps 1 to 3 for every time instant.</h5></li> <br><br>

            In a Madgwick filter, the only tunable parameter is trade off parameter \(\beta\) which determines when the gyro has to take over the acc. Also, the user needs to specify the initial estimates of the attitude, biases and sampling time. The initial attitude can be assumed to be zero if th device is at rest or it has to be obtained by external sources such as a motion capture system or a camera. The bias is computed by taking an average of samples with the IMU at rest and computing the mean value. Note that this bias changes over time and the filter will start to drift over time. The sampling time is the inverse of the operating frequency of the IMU and is specified generally at the driver level.<br><br>


            <hr>
            <a name='ref'></a>

            <h3>References</h3><br><br>

             <ul class="unordered-list">
            <li> <a href="https://ieeexplore.ieee.org/document/5975346">Sebastian OH Madgwick, Andrew JL Harrison, and Ravi Vaidyanathan. [Estimation of IMU and MARG orientation using a gradient descent algorithm, 2011 IEEE international conference on rehabilitation robotics. IEEE, 2011.</a> </li>

        </ul>





            </div>
        </div>
    </div>


            <!-- start footer Area -->
            <footer class="footer-area section-gap">
                <div class="container">
                    <div class="row">
                        <div class="col-lg-5 col-md-6 col-sm-6">
                            <div class="single-footer-widget">
                                <h4>About Me</h4>
                                <p>
                                    We have tested a number of registry fix and clean utilities and present our top 3 list on our site for your convenience.
                                </p>
                                <p class="footer-text"><!-- Link back to Colorlib can't be removed. Template is licensed under CC BY 3.0. -->
Copyright &copy;<script>document.write(new Date().getFullYear());</script> All rights reserved | This template is made with <i class="fa fa-heart-o" aria-hidden="true"></i> by <a href="https://colorlib.com" target="_blank">Colorlib</a>
<!-- Link back to Colorlib can't be removed. Template is licensed under CC BY 3.0. --></p>
                            </div>
                        </div>
                        <div class="col-lg-5 col-md-6 col-sm-6">
                            <div class="single-footer-widget">
                                <h4>Newsletter</h4>
                                <p>Stay updated with our latest trends</p>
								<div class="" id="mc_embed_signup">
									 <form target="_blank" action="https://spondonit.us12.list-manage.com/subscribe/post?u=1462626880ade1ac87bd9c93a&amp;id=92a4423d01" method="get">
									  <div class="input-group">
									    <input type="text" class="form-control" name="EMAIL" placeholder="Enter Email Address" onfocus="this.placeholder = ''" onblur="this.placeholder = 'Enter Email Address '" required="" type="email">
									    <div class="input-group-btn">
									      <button class="btn btn-default" type="submit">
									        <span class="lnr lnr-arrow-right"></span>
									      </button>    
									    </div>
									    	<div class="info"></div>  
									  </div>
									</form> 
								</div>
                            </div>
                        </div>
                        <div class="col-lg-2 col-md-6 col-sm-6 social-widget">
                            <div class="single-footer-widget">
                                <h4>Follow Me</h4>
                                <p>Let us be social</p>
                                <div class="footer-social d-flex align-items-center">
                                    <a href="#"><i class="fa fa-facebook"></i></a>
                                    <a href="#"><i class="fa fa-twitter"></i></a>
                                    <a href="#"><i class="fa fa-dribbble"></i></a>
                                    <a href="#"><i class="fa fa-behance"></i></a>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </footer>
            <!-- End footer Area -->		

			<script src="js/vendor/jquery-2.2.4.min.js"></script>
			<script src="js/popper.min.js"></script>
			<script src="js/vendor/bootstrap.min.js"></script>			
			<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBhOdIF3Y9382fqJYt5I_sswSrEw5eihAA"></script>			
  			<script src="js/easing.min.js"></script>			
			<script src="js/hoverIntent.js"></script>
			<script src="js/superfish.min.js"></script>	
			<script src="js/jquery.ajaxchimp.min.js"></script>
			<script src="js/jquery.magnific-popup.min.js"></script>	
    		<script src="js/jquery.tabs.min.js"></script>						
			<script src="js/jquery.nice-select.min.js"></script>	
            <script src="js/isotope.pkgd.min.js"></script>			
			<script src="js/waypoints.min.js"></script>
			<script src="js/jquery.counterup.min.js"></script>
			<script src="js/simple-skillbar.js"></script>							
			<script src="js/owl.carousel.min.js"></script>							
			<script src="js/mail-script.js"></script>	
			<script src="js/main.js"></script>	
		</body>
	</html>






